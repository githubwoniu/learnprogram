## 链接

https://leetcode.com/problems/roman-to-integer/

## 题目

将罗马数字转换为整形，输入范围是1-3999

## 释义

1-3999的罗马数，用到的符号和对应的十进制数如下：

I → 1

V → 5

X → 10

L → 50

C → 100

D → 500

M → 1000

书写规则大致如下，按照十进制的每一位数来描述

- 若该位为基准数（如1、10、100）的1-3倍，则通过连续书写表示相加，如III表示3
- 若为四倍，则改为书写一次，再加书写5倍的数，表示5-1，如4=5-1=IV
- 若为6-9倍，则先书写5的倍数，剩余数字按照1-4倍在后方追加书写。如8=5+3=VIII

## 补充描述

这题的解法，有两种：

1. 查表法，将上述七个罗马数符号打表，然后依次遍历，查表转换为整形；
2. switch-case法，其实就是把查表法展开成代码。

性能上，两者本质相同，查表法是通过下标进行数据寻址。switch-case是通过switch内容进行代码寻址。



#### 性能分析

**此段可以先不看，后续版本优化中看不懂了再倒回来看**

但需注意——现代CPU，具有流水线、分支预测、乱序执行等高性能流程，具体原理可以分别查询相关词汇的维基百科，我们在常规代码优化中，只需要注意这两点：

1. 避免条件判断，解释见后。
2. 避免代码跳转，解释见后。
3. 避免堆栈出入，如调用函数，进出{}语句块，这个为什么会有性能损耗应该不用解释了。

现代CPU在执行指令过程中，会通过流水线进行。

在执行当条指令同时，就会把后面的几条指令顺序读取进寄存器，以便后续工作。更丧病的情况下，会把后续指令的操作数也提前读取进来准备执行。

如果前后两条指令的数据没有相互依赖，那么就会在流水线里并行执行，也就是乱序执行。而条件判断则会打断这个提前读取，因为在判断成功之前，无法确定后续工作分支。

不过现代CPU大多具有分支预测技术，也就是如果同一个分支多次执行（如for里面的if），之前几次走的都是true，那么下一次就会按照true来提前处理，如果实际为false则回滚，实际为true则会继续，这样就避免了指令预处理、流水线等操作被条件语句打断。

而在实际场合中，分支预测成功率高达八成——也就是说，如果我们在for里面有if，那么只要这个if语句绝大部分情况下结果都相同（同为true或同为false），CPU分支预测技术就可以很大程度的避免了条件跳转带来的性能损失。而如果我们的if语句，true和false的成功率差异并不明显，那么这个多次执行的if，会显著拖慢执行效率，有时慢上一个数量级都不奇怪。

而代码跳转，如goto、switch-case，也会带来一定的性能损失，原因就和if判断之后的跳转相同。

扩展阅读：[CPU 的分支預測器是怎樣工作的？ - 知乎](https://www.zhihu.com/question/23973128)



所以，在一开始提到的查表法和switch-case法中，一般来说查表法性能会更高，因为不需要进行代码跳转。

那么，就开始编程吧！



#### 版本一

这一道题，解题思路上，可以打草稿来模拟计算，我用III(3)、IV(4)和VI(6)来进行推理。

- 从右往左数，最右边一个肯定是初始值。
- 往前逐一数过去，最简单的就是依次加上去，如III，就是1+1+1得到3，没毛病。
- 遇到不同的数，就要判断下了。从V到I(IV)，之前一步(V)是5，后一步(I)应该减掉。从I到V(VI)则相反。

于是就有了下面的代码：

```c++
class Solution {
public:
    int romanToInt(string s) {
        unordered_map<char, int> romanMap = { { 'I', 1 },
                                               { 'V', 5 },
                                               { 'X', 10 },
                                               { 'L', 50 },
                                               { 'C', 100 },
                                               { 'D', 500 },
                                               { 'M', 1000 } };
        int num = romanMap.at(s.back());
        for(int i=s.length()-2;i>=0;--i) {
            if(romanMap.at(s.at(i)) < romanMap.at(s.at(i+1)))
                num -= romanMap.at(s.at(i));
            else
                num += romanMap.at(s.at(i));
        }
        return num;
    }
};
```

在这里，我通过unordered_map创建了一张hash表，hash表的好处在于查询接近于常量级，效率极为接近数组下标寻址。

leetcode里，代码验证时的输入数据量好像不大，所以多次执行代码耗时波动很大。提交后点“more details”可以看耗时在所有答案里的排行。多数情况会稳定在一个较快的值，但也有许多时候会掉下去。

这个版本，多次执行后，比较稳定的快速数值，是超过了53.92%的人。



#### 版本二

我们注意到，在上个版本里，`romanMap.at(s.at(i))`这段代码出现了三次。也就是，出现了六次at寻址，但这六次的值其实是完全一样的。

于是，可以用一个变量来代替这段代码——`int cur = romanMap.at(s.at(i));`

而`romanMap.at(s.at(i+1))`这段，看似只出现了一次，但这一次其实是来自于上一次执行的cur，所以也可以把它优化掉，在循环结尾使用变量`prev = cur`来将其缓存。

于是有了下面的版本：

```c++
class Solution {
public:
    int romanToInt(string s) {
        unordered_map<char, int> romanMap = { { 'I', 1 },
                                               { 'V', 5 },
                                               { 'X', 10 },
                                               { 'L', 50 },
                                               { 'C', 100 },
                                               { 'D', 500 },
                                               { 'M', 1000 } };
        int num = romanMap.at(s.back());
        int prev = num;
        for(int i=s.length()-2;i>=0;--i) {
            int cur = romanMap.at(s.at(i));
            if(cur < prev)
                num -= cur;
            else
                num += cur;
            prev = cur;
        }
        return num;
    }
};
```

运行通过了，效率打败了55.88%对手。

这里把`romanMap.at(s.at(i+1))`替换为prev，究竟是赚是亏我没细细思考过，但cur变量显然是赚的，然而效率提升并不明显，也许prev变量略亏了一点？



#### 版本三（好孩子可以学

版本二已经可以作为比较完美的答案提交了，在执行效率和代码易读性上做到了平衡。

如果是**在工作环境里，版本二是最完美的！**

接下来，为了压榨性能的极限（毕竟这就是oj的目的），我们可以选择放弃代码可读性来提升性能。这一点在工作环境中极度不推荐，除非是底层的执行超级频繁，对性能影响很明显的核心代码。需牢记——**不要过度优化**。

```c++
class Solution {
public:
    int romanToInt(string s) {
        unordered_map<char, int> romanMap = { { 'I', 1 },
                                               { 'V', 5 },
                                               { 'X', 10 },
                                               { 'L', 50 },
                                               { 'C', 100 },
                                               { 'D', 500 },
                                               { 'M', 1000 } };
        int num = romanMap.at(s.back());
        int prev = num;
        for(int i=s.length()-2;i>=0;--i) {
            int cur = romanMap.at(s.at(i));
            int curLargerThanPrev = cur >= prev;
            num += (2 * curLargerThanPrev - 1) * cur;
            prev = cur;
        }
        return num;
    }
};
```

在这里，我把if语句弄没了……

循环体内，多次执行的if语句是万恶之源，对性能的影响非常严重。这题还好，if内的代码块里，就一行代码，运算量很小。如果代码块里的运算比较复杂的话，if带来的性能损失就很严重了。

我这里用了个trick，没去细查标准——bool其实是个单字节整形，它的true一般是1，false一般是0。具体的得去查c++规范了，我没具体验证过，但在常见编译器上是这样的。

于是，我们就能把这个if判断的判断条件，保存为一个整形值。然后把这个1/0的整形值，和if-else内的计算揉在一起，合并成一个东西。

具体思路是这样的:

```c++
result = isTrue * ...true expression... 
         + (1 - isTrue) * ...false expression...
```

参照这个写法，合并一下多项式，提取一下系数，就得到了上面的代码。

这版代码，效率提升没想象中明显，执行了多次后，稳定速度是打败了59.85%对手，偶尔可以蹦到60%甚至70%。

不过在我目前工作的项目中，核心算法里有许多地方用到了这样的trick。为避免bool→int的操作万一是Undefined behavior，我还牺牲了一定的性能把它写成`int isTrue = (boolean expression)?1:0`，但效率提升依旧很明显。



#### 最终版（好孩子不要学

其实，我大学是水过去的，大四做毕设才先学的Qt做GUI，结果还是没学会，答辩时用Qt Designer画了个ui截图写进论文……

还好我们大学的软件是中期答辩时演示，之后就只需要论文了。中期那会儿我还可以借口说界面还没做好来推脱，然后我把界面原型和纯命令行的核心功能代码分别演示了下，老师很大度的让我过了……

毕业工作后，才开始好好的学C++和Qt，并且因为一开始就入了Qt坑，导致我到现在工作三年多了，对boost都只是一知半解，STL也是从半年前才开始好好学的……

至于ACM、OJ这些东西，那更是离我很远，我现在是用可以做TL的工作经验，高屋建瓴的逆推这些知识……

而这个领域里，着重于算法，所以C++和面向对象其实用处不大，核心还是C的那一套。

而当我知道了打表法的存在时，简直是毁三观了，觉得这完全是作弊……但反过来一想，工程领域不就是满满的将就和凑合么，在可以接受的精度或其他损失范围内，能够提高N个数量级完成工作的方法，就是最完美的方法，比如打表法。

像这题，最直观的其实应该是switch-case，但最快的却是打表法。

但打表法的最高境界，是数组，而且是写在栈上的数组，而不是new出来的堆数组（我都不提ACM里，通过预编译指令把栈扩容到几十几百兆然后全程在栈上写算法的奇技淫巧了……）。而这里用的只不过是unordered_map，虽然hash理论查询性能是O(1)，但比起真正O(1)的数组下标访问，还是有那么点常数上的差距的。

于是，有了最终版的代码，丧心病狂的打表。如果看不懂的话，可以看一下I、V、X、L、C、D、M的ASCII码，你就懂了。



## 代码

```c++
class Solution {
public:
    int romanToInt(string s) {
    int romanMap['X'+1] = { 0, 0, 0, 0, 0, 0,  0,    0,   0, 0,
                            0, 0, 0, 0, 0, 0,  0,    0,   0, 0,
                            0, 0, 0, 0, 0, 0,  0,    0,   0, 0,
                            0, 0, 0, 0, 0, 0,  0,    0,   0, 0,
                            0, 0, 0, 0, 0, 0,  0,    0,   0, 0,
                            0, 0, 0, 0, 0, 0,  0,    0,   0, 0,
                            0, 0, 0, 0, 0, 0,  0,  100, 500, 0,
                            0, 0, 0, 1, 0, 0, 50, 1000,   0, 0,
                            0, 0, 0, 0, 0, 0,  5,    0,  10 };
        int num = romanMap[s.back()];
        int prev = num;
        for(int i=s.length()-2;i>=0;--i) {
            int cur = romanMap[s.at(i)];
            int curLargerThanPrev = cur >= prev;
            num += (2 * curLargerThanPrev - 1) * cur;
            prev = cur;
        }
        return num;
    }
};
```

这个版本，平均性能在60-80%，最高打败了97.73%的对手。

没毛病！



#### 扩展阅读

可惜leetcode不支持rust，不然我觉得，rust的pattern match，也许是最快的。

github上有个多语言性能的benchmark项目，其中有个test case是实现一个简易的js解释器。

这个题目里，ruby等对于字符串处理有丧心病狂的优化的动态语言，性能甚至超过了用switch-case的C/C++——要知道，在其他题目里，C/C++相比动态语言都有着最少一个数量级的碾压优势。

然而rust用接近一个数量级的差距碾压了这些对手……用的就是pattern match，代码极度简洁优雅。

可惜我一直没空学rust……



## 更多

![](https://github.com/githubwoniu/learnprogram/blob/master/image/erweima.png)

PS: 请保留二维码链接，以便更多人参与进来。谢谢。
